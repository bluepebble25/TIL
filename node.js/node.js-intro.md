# Node.js - Intro

## Node.js란?
JS는 원래 브라우저라는 프로그램 위에서만 실행할 수 있었다. Node.js는 Chrome에도 사용된 V8이라는 Javascript 엔진을 기반으로  만들어져, 브라우저에 종속되지 않고 외부 환경에서 JS를 실행할 수 있게 한다.

`Node.js®는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임입니다.`라고 공식 사이트에서 소개하고 있다. 런타임(run time)이란 JS가 구동되는 환경을 의미한다. Node.js는 JS를 실행할 수 있는 '환경'이기 때문에 이 자체로는 아무것도 하지 못한다. 따라서 서버도 직접 구현해줘야 한다. 서버 구현도 어렵지 않은데, Node에는 편리한 자체 모듈들이 내장되어 있기 때문에 서버도 손쉽게 구축할 수 있다. 예를 들어 http 모듈을 import 하는 것만으로도 간편하게 서버를 구축할 수 있고, Socket.io 모듈로는 소켓 통신을 쉽게 할 수 있다. 그리고 NPM이라는 패키지 매니저를 제공하기 때문에 외부 모듈을 다운받거나 환경 설정을 쉽게 할 수 있다.

## Node.js 특징
- 단일 스레드
- 이벤트 기반 비동기방식(Non Blocking I/O)

**스레드 기반 동기방식(Blocking I/O)**  
어떤 일을 request 받으면 끝날 때까지 기다렸다가 응답을 하고, 일이 끝나기 전 다른 요청을 받았다면 새로운 스레드를 생성해 동시에 일을 처리한다. 따라서 동시 request가 많은 경우 쓰레드가 늘어나 서버에 과부하가 온다.

**단일 스레드 이벤트 기반 비동기방식(Non Blocking I/O)**  
하나의 스레드로 모든 일을 처리한다. 단, 일처리하는데 한 개의 스레드만 있으면 비동기방식으로 운영을 할 수 없다. 따라서 요청을 받으면 워커 스레드들을 생성해 일을 시키고, 결과를 비동기적으로 받아보는 일만 하는 스레드를 어플리케이션에 하나 두고 싱글 스레드라고 하는 것이다. 이 싱글 스레드를 이벤트 루프라고 한다. 이런 방식의 싱글 스레드는 프로그래머가 추상적인 레벨에서 스레드를 다룰 수 있게 해준다.

**이벤트 루프**는 요청을 받으면 워커 스레드를 생성하고 콜백함수를 함께 등록한다. 여러 개의 요청을 받으면 결과가 끝날 때까지 기다리는 게 아니라 새로운 워커 스레드와 콜백함수를 생성한다. 요청된 작업 한 개가 끝나면 워커 스레드가 콜백함수를 실행해 이벤트 루프가 작업의 종료를 감지하고 결과를 받아온다.

### 장점
- V8 엔진을 사용하기 때문에 속도가 빠르다. 그리고 싱글 스레드이기 때문에 멀티 스레드와는 다르게 요청이 많아져도 메모리 사용량에 부담이 가지 않는다.
- 따라서 대규모 네트워크 프로그램, 입출력이 많은 서비스, 빠른 속도가 필요한 SPA, 비동기 처리가 많은 서비스(스트리밍, 채팅) 개발에 적합하다.
- JS를 사용하기 때문에 JSON 형식과 호환이 쉽다.

### 단점
- 이벤트 기반 비동기방식이라 서버단 로직이 복잡한 경우 콜백함수의 늪에 빠질 수 있다.
- 싱글 스레드 모델이기 때문에 하나의 작업 자체가 시간이 많이 걸리면 전체 시스템의 성능이 아주 급격하게 나빠지므로 CPU 사용률이 높은 애플리케이션에는 Node.js 사용이 권장되지 않는다.
- 싱글 스레드이므로 스레드에 문제가 생기면 프로세스가 중지된다. 따라서 오류가 나지 않도록 모든 테스트 케이스를 검증하는 것이 중요하다.

## 프론트엔드 개발자에게 Node.js가 필요한 이유
> NPM 쓰려고!

1. 편리한 외부 모듈(도구) 다운받을 수 있게 해줌 - NPM 사이트에 누군가 만들어서 업로드한 패키지(다른 사람이 작성한 외부 모듈)를 `npm install 패키지명`로 다운받을 수 있다. Typescript, SASS, Babel, Webpack, Eslint, CRA(create-react-app) ...
2. 간편한 라이브러리 버전관리 - CDN(클라우드에 존재하는 라이브러리를 script 태그로 불러와 네트워크를 통해 전송받는 방식)을 이용하면 버전을 확인하거나 바꾸고 싶은 경우 일일이 소스코드를 뒤져서 찾아야 한다. 그리고 인터넷 연결이 끊긴 경우 프로그램이 동작하지 않을 수 있다. npm을 이용해 모듈을 다운받고, package.json 파일을 통해 손쉽게 버전관리를 할 수 있다.
3. 스크립트로 반복입력 줄이기 및 빌드 자동화 가능
     - 빌드(build), 린트(lint), 포멧(format), 테스트(test)처럼 반복적으로 수행해야하는 작업들을 스크립트에 추가해 더 짧은 명령어로 실행할 수 있다.
     - build 명령어에 `webpack --watch`를 설정해놓으면 `npm run build`를 한번만 실행해놓아도 종료되지 않고 변경 사항이 감지될 때마다 다시 빌드를 한다. 그리고 gulp라는 도구를 이용해 빌드 할 때 해야하는 여러 작업을 자동화 할 수도 있다.
4. 개발 환경 커스터마이징 - 언제까지나 CRA처럼 이미 제공된 환경 그대로 사용할 수는 없다. 커스터마이징 해야 하는데 이럴 때 npm과 node.js에 대한 지식이 있다면 앞에서 나온 스크립트 설정이나 라이브러리 버전 관리처럼 자신에게 맞는 환경을 구축할 수 있다.

## npm init
새로운 프로젝트를 시작하거나 패키지를 만들 때 그에 대한 설명이 필요하다. ex) 프로젝트 이름, 버전, 메인 파일, 의존성(이 프로젝트가 필요로 하는 다른 패키지)

package.json은 프로젝트나 패키지에 대한 정보를 담고 있는 환경설정 파일이다. 직접 package.json을 생성할 수도 있지만 `npm init`이라고 입력하면 npm이 질문을 하고, 그에 대한 답을 하는 것만으로도 손쉽게 파일을 생성할 수 있다. 아래는 myproject라는 프로젝트 폴더를 생성한 후, npm init에 기본값으로 답한 결과이다.

```json
{
  "name": "myproject",
  "version": "1.0.0",
  "description": "test",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}
```

package.json 덕분에 프로젝트 폴더 안에 있는 크고 무거운 `node-modules`를 공유하지 않고도 `package.json`을 통해 똑같은 환경을 구축할 수 있다.

## Reference
- [(Node.js) Node.js란? | Medium
](https://medium.com/@su_bak/node-js-node-js%EB%9E%80-410ae3749c56)
- [프론트엔드 개발환경의 이해: NPM](https://jeonghwan-kim.github.io/series/2019/12/09/frontend-dev-env-npm.html)
- [[Node.js 1강]node js 란? 장점, 단점, 어떤 웹서비스에 사용해야할까?](https://junspapa-itdev.tistory.com/3)
- https://velog.io/@deannn/Node.js-Node.js%EC%9D%98-%EC%86%8C%EA%B0%9C%EC%99%80-%ED%8A%B9%EC%A7%95
- https://www.hyojae.info/db57bc7b-0fbd-46bc-a71b-e45bcbfad26e#2faced60-9406-4644-b41f-a29878f6367d
- https://psawesome.tistory.com/28